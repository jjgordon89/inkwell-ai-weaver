import { useState, useEffect, useCallback, useRef } from 'react';
import { useAI } from './useAI';
import { useWriting } from '@/contexts/WritingContext';
import { useDebounce } from './useDebounce';

interface AISuggestion {
  id: string;
  type: 'completion' | 'improvement' | 'character' | 'plot';
  text: string;
  confidence: number;
  position?: { start: number; end: number };
  original?: string;
}

interface WritingContext {
  currentText: string;
  cursorPosition: number;
  selectedText: string;
  characters: string[];
  currentChapter?: string;
}

export const useCollaborativeAI = () => {
  const { processText, isProcessing } = useAI();
  const { state } = useWriting();
  const [suggestions, setSuggestions] = useState<AISuggestion[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [writingContext, setWritingContext] = useState<WritingContext>({
    currentText: '',
    cursorPosition: 0,
    selectedText: '',
    characters: []
  });

  const debouncedText = useDebounce(writingContext.currentText, 2000);
  const analysisRef = useRef<AbortController | null>(null);

  const analyzeWritingContext = useCallback(async (context: WritingContext) => {
    if (!context.currentText || context.currentText.length < 50) return;

    // Cancel previous analysis
    if (analysisRef.current) {
      analysisRef.current.abort();
    }
    analysisRef.current = new AbortController();

    setIsAnalyzing(true);
    try {
      const prompt = `Analyze this writing context and provide helpful suggestions:

Current text: "${context.currentText.slice(-500)}"
Characters mentioned: ${context.characters.join(', ')}

Provide 2-3 contextual suggestions for:
1. Writing flow improvements
2. Character development opportunities
3. Plot advancement ideas

Format as: Type: suggestion text (confidence: 0-100)`;

      const result = await processText(prompt, 'context-suggestion');
      
      // Parse suggestions
      const newSuggestions: AISuggestion[] = [];
      const lines = result.split('\n').filter(line => line.trim());
      
      lines.forEach((line, index) => {
        const match = line.match(/^(\w+):\s*(.+?)\s*\(confidence:\s*(\d+)\)/);
        if (match) {
          const [, type, text, confidence] = match;
          newSuggestions.push({
            id: `suggestion-${Date.now()}-${index}`,
            type: type.toLowerCase() as AISuggestion['type'],
            text: text.trim(),
            confidence: parseInt(confidence, 10)
          });
        }
      });

      if (!analysisRef.current.signal.aborted) {
        setSuggestions(newSuggestions);
      }
    } catch (error) {
      if (!analysisRef.current?.signal.aborted) {
        console.error('Context analysis failed:', error);
      }
    } finally {
      setIsAnalyzing(false);
      analysisRef.current = null;
    }
  }, [processText]);

  const generateTextCompletion = useCallback(async (textBefore: string, textAfter: string) => {
    if (textBefore.length < 10) return null;

    try {
      const prompt = `Complete this text naturally, maintaining the style and flow:

Before: "${textBefore.slice(-200)}"
After: "${textAfter.slice(0, 100)}"

Provide a natural completion (2-10 words) that bridges the text smoothly:`;

      const completion = await processText(prompt, 'continue-story');
      return completion.trim();
    } catch (error) {
      console.error('Text completion failed:', error);
      return null;
    }
  }, [processText]);

  const extractSuggestionText = (result: string): string => {
    // Remove anything after a parenthesis that looks like an explanation
    const idx = result.indexOf('(');
    let main = idx > 0 ? result.slice(0, idx) : result;
    // Remove anything after a double newline (often separates suggestion from explanation)
    main = main.split(/\n\n|\r\n\r\n/)[0];
    // Remove lines that look like explanations, bullet points, or meta-comments
    const lines = main.split(/\r?\n/).filter(line =>
      !/^[\s-]*[*\d]+[.:)]?\s*/.test(line) && // skip bullet points and numbered lists
      !/^\s*I made/.test(line) && // skip explanation phrases
      !/^\s*changes?\b/i.test(line) &&
      !/^\s*improvements?\b/i.test(line) &&
      !/^\s*in summary/i.test(line) &&
      !/^\s*here'?s?\b/i.test(line) &&
      !/^\s*note\b/i.test(line) &&
      !/^\s*\(.+\)$/.test(line) && // skip parenthetical lines
      !/^\s*(Enhanced version|Generated by|Model:|AI model:|Using model:|Powered by)\b/i.test(line) // skip model metadata
    );
    // Join all remaining lines for a multi-sentence suggestion
    return lines.filter(line => line.trim().length > 0).join(' ').trim();
  };

  const improveSelectedText = useCallback(async (selectedText: string) => {
    if (!selectedText || selectedText.length < 5) return null;

    try {
      const result = await processText(selectedText, 'improve');
      return {
        id: `improvement-${Date.now()}`,
        type: 'improvement' as const,
        text: extractSuggestionText(result),
        confidence: 85,
        original: selectedText
      };
    } catch (error) {
      console.error('Text improvement failed:', error);
      return null;
    }
  }, [processText]);

  const generateContextualSuggestions = useCallback(async (
    documentContent: string,
    selectedText?: string,
    characters?: Array<{ id: string; name: string }>,
    storyArcs?: Array<{ id: string; title: string }>
  ): Promise<string[]> => {
    if (!documentContent || documentContent.length < 50) return [];

    try {
      const prompt = `Based on this story context:
Content: "${documentContent.substring(0, 1000)}"
${selectedText ? `Selected text: "${selectedText}"` : ''}
Characters: ${characters?.map(c => c.name).join(', ') || 'None'}
Story arcs: ${storyArcs?.map(a => a.title).join(', ') || 'None'}

Provide 3-5 contextual writing suggestions that enhance the narrative.

Format as a simple list, one suggestion per line.`;

      const result = await processText(prompt, 'context-suggestion');
      return result.split('\n')
        .map(line => line.trim().replace(/^[-*]\s*/, ''))
        .filter(line => line.length > 0);
    } catch (error) {
      console.error('Contextual suggestions failed:', error);
      return [];
    }
  }, [processText]);

  // Auto-analyze when text changes
  useEffect(() => {
    if (debouncedText) {
      analyzeWritingContext(writingContext);
    }
  }, [debouncedText, analyzeWritingContext, writingContext]);

  // Update context when writing state changes
  useEffect(() => {
    setWritingContext({
      currentText: state.currentDocument?.content || '',
      cursorPosition: 0,
      selectedText: state.selectedText,
      characters: state.characters.map(c => c.name),
      currentChapter: state.currentDocument?.title
    });
  }, [state.currentDocument, state.selectedText, state.characters]);

  const dismissSuggestion = useCallback((suggestionId: string) => {
    setSuggestions(prev => prev.filter(s => s.id !== suggestionId));
  }, []);

  const clearAllSuggestions = useCallback(() => {
    setSuggestions([]);
  }, []);

  return {
    suggestions,
    isAnalyzing: isAnalyzing || isProcessing,
    writingContext,
    generateTextCompletion,
    improveSelectedText,
    generateContextualSuggestions,
    dismissSuggestion,
    clearAllSuggestions,
    updateContext: setWritingContext
  };
};
